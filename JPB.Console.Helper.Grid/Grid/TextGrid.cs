using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using JetBrains.Annotations;

namespace JPB.Console.Helper.Grid.Grid
{
	public class ColumnInfo : IColumnInfo
	{
		public string Value { get; set; }
		public AlignedProperty Size { get; set; }
		public ConsoleGridColumn ColumnElementInfo { get; set; }
	}
	
	[PublicAPI]
	public class TextGrid<T>
	{
		private static readonly Assembly _msCoreLib = typeof(string).Assembly;

		private IConsolePropertyGridStyle _consolePropertyGridStyle;

		private StringBuilder _extraInfos;
		private T _focusedItem;
		private ObservableCollection<T> _sourceList;

		/// <inheritdoc />
		/// <param name="columnGenerationMode">if set to
		///     <value>ColumnGenerationMode.AutoGenerate</value>
		///     all collums will be autogenerated by using the Propertys
		/// </param>
		/// <param name="generateTypeInName"></param>
		public TextGrid(ColumnGenerationMode columnGenerationMode = ColumnGenerationMode.AutoGenerate,
			bool generateTypeInName = true) : this()
		{
			RenderTypeName = generateTypeInName;
			ColumnGenerationMode = columnGenerationMode;

			if (ColumnGenerationMode == ColumnGenerationMode.AutoGenerate)
			{
				GenerateColumns();
			}
		}

		/// <summary>
		/// Attaches the grid to the console.
		/// </summary>
		/// <param name="columnGenerationMode">The column generation mode.</param>
		/// <param name="generateTypeInName">if set to <c>true</c> [generate type in name].</param>
		/// <param name="clearConsole">if set to <c>true</c> [clear console].</param>
		/// <returns></returns>
		public static TextGrid<T> AttachToConsole(
			ColumnGenerationMode columnGenerationMode = ColumnGenerationMode.AutoGenerate,
			bool generateTypeInName = true,
			bool clearConsole = false)
		{
			var grid = new TextGrid<T>(columnGenerationMode, generateTypeInName);
			grid.DrawEnvironment = new ConsoleDrawEnvironment();
			grid.NeedsRedraw += (sender, interlaced) => { interlaced.WriteToConsole(clearConsole); };
			return grid;
		}

		/// <summary>
		///     Creates a new Text Grid
		/// </summary>
		public TextGrid()
		{
			Target = typeof(T);
			ExpandConsole = true;
			ClearConsole = true;
			ObserveList = true;
			SelectedItems = new ObservableCollection<T>();
			SourceList = new ObservableCollection<T>();
			ConsolePropertyGridStyle = new DefaultConsolePropertyGridStyle();
			Columns = new List<ConsoleGridColumn>();
			Filter = f => true;
			_extraInfos = new StringBuilder();
			Null = "{NULL}";
			RenderTypeName = true;
			DrawEnvironment = new ConsoleDrawEnvironment();
			RegisteredChangeHandler = new ConditionalWeakTable<INotifyPropertyChanged, IDisposable>();
		}

		public event EventHandler<StringBuilderInterlaced> NeedsRedraw; 
		

		[PublicAPI]
		public static void RenderListToConsole(IEnumerable<T> select)
		{
			var grid = AttachToConsole();
			grid.SourceList = new ObservableCollection<T>(select);
			grid.RenderGrid().WriteToConsole();
		}

		/// <summary>
		///     The Target type that will be contained in the Grid
		/// </summary>
		public Type Target { get; set; }

		private ConditionalWeakTable<INotifyPropertyChanged, IDisposable> RegisteredChangeHandler { get; }

		/// <summary>
		///     The List of items that the Grid will be rendered off.
		///     by setting there will be NO redraw. Only if you add or remove items from the list and <code>ObserveList</code> is
		///     set to true
		/// </summary>
		public ObservableCollection<T> SourceList
		{
			get => _sourceList;
			set
			{
				if (_sourceList != null)
				{
					foreach (var item in _sourceList)
					{
						if (item is INotifyPropertyChanged)
						{
							(item as INotifyPropertyChanged).PropertyChanged -= OnIsNotifyableOnPropertyChanged;
						}
					}
				}

				_sourceList = value;
			}
		}

		/// <summary>
		///     The list of selected items. Must not be set and can be recived.
		/// </summary>
		public ObservableCollection<T> SelectedItems { get; set; }

		/// <summary>
		///     A filter that can be applyed to the <code>SourceList</code>
		/// </summary>
		public Func<T, bool> Filter { get; }

		/// <summary>
		///     The currently Focused item. Setting the FocusedItem will cause in a Redraw.
		/// </summary>
		public T FocusedItem
		{
			get => _focusedItem;
			set
			{
				_focusedItem = value;
				if (value != null)
				{
					RenderGrid();
				}
			}
		}

		/// <summary>
		///     Additonal Infos that will be rendered to the Grid
		/// </summary>
		public StringBuilder ExtraInfos
		{
			get => _extraInfos;
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}

				_extraInfos = value;
			}
		}

		/// <summary>
		///     A style that will be used to Render the Grid. It defines all chars and functions to Draw the Grid.
		/// </summary>
		public IConsolePropertyGridStyle ConsolePropertyGridStyle
		{
			get => _consolePropertyGridStyle;
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}

				_consolePropertyGridStyle = value;
			}
		}

		/// <summary>
		///     Should the text be centerd
		/// </summary>
		public bool CenterText { get; set; }

		/// <summary>
		///     If enabled, it will be tried to expand the console's size to its complete width
		///     If this is not possible UI Bugs will be visibile ... WIP
		/// </summary>
		public bool ExpandConsole { get; set; }

		/// <summary>
		///     Clear the console bevor drawing
		/// </summary>
		public bool ClearConsole { get; set; }

		/// <summary>
		///     Attach to the Source list and ReRender the grid when the items change
		/// </summary>
		public bool ObserveList { get; set; }

		/// <summary>
		///     The text render object for null
		/// </summary>
		public string Null { get; set; }

		/// <summary>
		///     Render a Sum text at bottom
		/// </summary>
		public bool RenderSum { get; set; }

		/// <summary>
		///     Clear the Additional Infos Builder after use
		/// </summary>
		public bool PersistendAdditionalInfos { get; set; }

		/// <summary>
		///     Add a Auto column with the Row number
		/// </summary>
		public bool RenderRowNumber { get; set; }

		/// <summary>
		///     Should the type of the Property added
		/// </summary>
		public bool RenderTypeName { get; set; }

		/// <summary>
		///     Sets the Column Generation
		/// </summary>
		public ColumnGenerationMode ColumnGenerationMode { get; }

		/// <summary>
		///     All Column informations
		/// </summary>
		public IList<ConsoleGridColumn> Columns { get; }

		public IDrawEnvironment DrawEnvironment { get; set; }

		private void GenerateColumns()
		{
			if (_msCoreLib.GetTypes().Contains(Target))
			{
				Columns.Add(new ConsoleGridColumn("Value")
				{
					AutoGenerated = true,
					GetValue = f => f
				});
				return;
			}


			IEnumerable<PropertyInfo> properties;

#if NET_CORE
			properties = Target.GetRuntimeProperties();
#else
			properties = Target.GetProperties();
#endif
			foreach (var consoleGridColumn in properties.Select(s =>
			{
				var name = s.Name;
				if (RenderTypeName)
				{
					name = string.Format("{0} <{1}>", name, s.PropertyType.ToString());
				}

				var valueInformations = new ConsoleGridColumn(name)
				{
					GetValue = s.GetValue,
					AutoGenerated = true
				};

				return valueInformations;
			}))
			{
				Columns.Add(consoleGridColumn);
			}
		}

		private void RecalcColumns()
		{
			foreach (var consoleGridColumn in Columns)
			{
				consoleGridColumn.MaxContentSize = SourceList.Max(e =>
				{
					var value = consoleGridColumn.GetValue(e);
					if (value != null)
					{
						return value.ToString().Length;
					}

					return Null.ToString().Length;
				});
			}
		}

		/// <summary>
		///     Renders the Grid into a StringBuilderInterlaced
		/// </summary>
		/// <param name="flushToConsoleStream"></param>
		/// <returns></returns>
		public StringBuilderInterlaced RenderGrid(bool flushToConsoleStream = true)
		{
			var stream = new StringBuilderInterlaced();

			SourceList.CollectionChanged -= SourceListOnCollectionChanged;

			if (ObserveList)
			{
				SourceList.CollectionChanged += SourceListOnCollectionChanged;
			}

			var props = Columns;
			var fakeId = 0;
			IEnumerable<T> sourceList = SourceList;

			if (Filter != null)
			{
				sourceList = sourceList.Where(Filter);
			}

			var size = 0;
			sourceList = sourceList.ToArray();
			var fod = sourceList.FirstOrDefault();
			var length = sourceList.Count();

			if (fod == null)
			{
				return null;
			}

			RecalcColumns();

			if (RenderRowNumber)
			{
				//fake new Column
				if (props.All(f => !f.AutoGenerated && f.Name != "Nr"))
				{
					props.Insert(0, new ConsoleGridColumn("#")
					{
						AutoGenerated = true,
						MaxContentSize = length.ToString().Length,
						GetValue = o => fakeId++
					});
				}
			}

			var allCollumns = props.Select(f => f.MaxContentSize).Aggregate((e, f) => e + f);

			if (allCollumns > DrawEnvironment.Width)
			{
				var partialForAllElements = DrawEnvironment.Width / props.Count;
				foreach (var valueInfo in props)
				{
					if (valueInfo.MaxContentSize > partialForAllElements)
					{
						valueInfo.MaxContentSize = partialForAllElements;
						valueInfo.AlignedProperty = AlignValueToSize(valueInfo.Name, partialForAllElements, CenterText);
					}
					else
					{
						valueInfo.AlignedProperty = AlignValueToSize(valueInfo.Name, valueInfo.MaxSize, CenterText);
					}

					valueInfo.Name = valueInfo.AlignedProperty.Text;
					size += valueInfo.Name.Length;
				}
			}
			else
			{
				foreach (var valueInfo in props)
				{
					valueInfo.AlignedProperty = AlignValueToSize(valueInfo.Name, valueInfo.MaxSize, CenterText);
					valueInfo.Name = valueInfo.AlignedProperty.Text;
					size += valueInfo.Name.Length;
				}
			}

			ConsolePropertyGridStyle.RenderHeader(stream, props);

			stream.AppendLine();

			if (ExpandConsole && DrawEnvironment.Width < size && DrawEnvironment.MaxWidth >= size)
			{
				DrawEnvironment.Width = size + 1;
			}

			var toRender = new List<RenderItem>();
			foreach (var item in sourceList)
			{
				toRender.Add(new RenderItem
				{
					Item = item,
					ColumnInfos = props.Select(f => new
						{
							Value = (f.GetValue(item) ?? Null).ToString(),
							ColumnInfo = f
						})
						.Select(f =>
						{
							var corrected = AlignValueToSize(f.Value, f.ColumnInfo.MaxSize, CenterText);
							return new ColumnInfo
							{
								Value = corrected.Text,
								Size = corrected,
								ColumnElementInfo = f.ColumnInfo
							};
						}).ToArray()
				});
			}

			var ix = 0;

			foreach (var element in toRender)
			{
				var item = element.Item;
				var rowsForThisItem = element.ColumnInfos.Max(f => f.Size.Rows);

				var selected = SelectedItems != null && SelectedItems.Contains(item);
				var focused = FocusedItem != null && FocusedItem.Equals(item);
				for (var i = 0; i < rowsForThisItem; i++)
				{
					ConsolePropertyGridStyle.BeginRenderProperty(stream, ix, length.ToString().Length, selected,
						focused);
					var columnIndex = 0;
					foreach (var column in element.ColumnInfos)
					{
						var toValue = column.Value.Skip(i * column.ColumnElementInfo.MaxSize)
							.Take(column.ColumnElementInfo.MaxSize)
							.Select(f => f.ToString()).ToArray();

						string toRenderThisRow;
						if (toValue.Any())
						{
							toRenderThisRow = toValue.Aggregate((e, f) => e + f);
						}
						else
						{
							toRenderThisRow = AlignValueToSize("", column.ColumnElementInfo.MaxSize, CenterText).Text;
						}

						ConsolePropertyGridStyle.RenderNextProperty(stream, toRenderThisRow, column, item, ix,
							columnIndex, selected, focused);
						ConsolePropertyGridStyle.EndRenderProperty(stream, ix, selected, focused);
						columnIndex++;
					}

					stream.AppendLine();
				}

				ix++;
			}

			for (var i = 0; i < length; i++)
			{
				var item = SourceList[i];
				var isNotifyable = item as INotifyPropertyChanged;
				if (isNotifyable != null)
				{
					isNotifyable.PropertyChanged -= OnIsNotifyableOnPropertyChanged;
					isNotifyable.PropertyChanged += OnIsNotifyableOnPropertyChanged;
					RegisteredChangeHandler.Add(isNotifyable,
						new DisposableAction(() =>
						{
							isNotifyable.PropertyChanged -= OnIsNotifyableOnPropertyChanged;
						}));
				}
			}
			

			ConsolePropertyGridStyle.RenderFooter(stream, props);
			stream.AppendLine();

			if (RenderSum)
			{
				ConsolePropertyGridStyle.RenderSummary(stream, length);
				stream.AppendLine();
			}

			if (_extraInfos.Length > 0)
			{
				ConsolePropertyGridStyle.RenderAdditionalInfos(stream, _extraInfos);
				stream.AppendLine();
			}

			if (!PersistendAdditionalInfos)
			{
				_extraInfos.Clear();
			}

			if (flushToConsoleStream)
			{
				stream.WriteToConsole(ClearConsole);
			}

			return stream;
		}

		private void OnIsNotifyableOnPropertyChanged(object sender, PropertyChangedEventArgs args)
		{
			RenderGrid();
		}

		public static AlignedProperty AlignValueToSize(string source, int max, bool center)
		{
			var overflow = (int) Math.Ceiling((float) source.Length / max);

			if (overflow > 1)
			{
				max = max * overflow;
			}

			var ghostLineBreak = "";
			for (var i = 0; i < max; i++)
			{
				ghostLineBreak += " ";
			}

			source = source.Replace(Environment.NewLine, ghostLineBreak);

			var placeLeft = max - source.Length;
			var value = "";
			int left;
			int right;

			if (center)
			{
				left = placeLeft / 2;
				right = placeLeft / 2;

				if (placeLeft > 0 && placeLeft % 2 != 0)
				{
					left += 1;
				}

				for (var j = 0; j < left; j++)
				{
					value += " ";
				}

				value += source;

				for (var r = 0; r < right; r++)
				{
					value += " ";
				}
			}
			else
			{
				left = 0;
				right = placeLeft;
				value += source;
				for (var r = 0; r < right; r++)
				{
					value += " ";
				}
			}

			return new AlignedProperty
			{
				Columns = 1,
				Rows = overflow,
				Text = value,
				UnusedSpace = value.Length - (right + left)
			};
		}

		private void SourceListOnCollectionChanged(object sender,
			NotifyCollectionChangedEventArgs notifyCollectionChangedEventArgs)
		{
			OnNeedsRedraw(RenderGrid());
		}

		private class RenderItem
		{
			public IEnumerable<ColumnInfo> ColumnInfos { get; set; }

			public T Item { get; set; }
		}

		protected virtual void OnNeedsRedraw(StringBuilderInterlaced e)
		{
			NeedsRedraw?.Invoke(this, e);
		}
	}

	public class DisposableAction : IDisposable
	{
		private readonly Action _onDispose;

		public DisposableAction(Action onDispose)
		{
			_onDispose = onDispose;
		}

		public void Dispose()
		{
			Dispose(true);
		}

		public void Dispose(bool dispose)
		{
			if (dispose)
			{
				GC.SuppressFinalize(this);
			}

			_onDispose();
		}

		~DisposableAction()
		{
			Dispose(false);
		}
	}
}